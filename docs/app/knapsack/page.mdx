# 背包问题

01 背包: n 种物品, 每种物品只有一个
多重背包: n 种物品, 每种物品有若干个
完全背包: n 种物品, 每种物品有无数个

## 01 背包

| 物品 | 重量 w | 价值 v |
| ---- | ------ | ------ |
| 0    | 2      | 10     |
| 1    | 3      | 5      |
| 2    | 5      | 15     |
| 3    | 7      | 7      |
| 4    | 1      | 6      |
| 5    | 4      | 18     |
| 6    | 1      | 3      |

### 动态规划

**考虑子问题**

> dp[i][j]: 下标 [0, i) 的物品, 放入容量为 j 的背包的最大价值

当前的价值 dp[i][j], 只取决于是否放入物品 i-1

```ts
dp[i][j] = // 下标 [0, i) 的物品, 放入容量为 j 的背包的最大价值
  Math.max(
    // 不放物品 i-1
    // 则 dp[i][j] = 下标 [0, i-1) 的物品, 放入容量为 j 的背包的最大价值
    dp[i - 1][j],
    // 放物品 i-1
    // 则 dp[i][j] = 下标 [0, i-1) 的物品, 放入容量为 j-w[i] 的背包的最大价值,
    // 再加上 物品 i-1 的价值
    dp[i - 1][j - w[i]] + v[i],
  );
```

**初始化 dp 数组**

- 只需要初始化第 0 行的所有元素, 和第 0 列的所有元素
- 第 0 行的元素表示下标 [0, 0) 空集的物品, 放入容量为 j 的背包的最大价值
  => `dp[0][j] = 0`
- 第 0 列的元素表示放入容量为 0 的背包 => `dp[i][0] = 0`
